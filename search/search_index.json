{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pattern Book This is a pattern log for common conflicts that may occur during our project. Pattern Layout: Title: name of issue Forces: explaination of issue Resolution: step by step instructions to solve issue Preceding patterns: issues that may occur before this Following patterns: issues that may occur after this","title":"Pattern Book"},{"location":"#pattern-book","text":"This is a pattern log for common conflicts that may occur during our project.","title":"Pattern Book"},{"location":"#pattern-layout","text":"Title: name of issue Forces: explaination of issue Resolution: step by step instructions to solve issue Preceding patterns: issues that may occur before this Following patterns: issues that may occur after this","title":"Pattern Layout:"},{"location":"Factory-Method/","text":"Forces: explaination of issue Resolution: step by step instructions to solve issue Preceding patterns: issues that may occur before this Following patterns: issues that may occur after this","title":"Factory Method"},{"location":"Factory-Method/#forces","text":"explaination of issue","title":"Forces:"},{"location":"Factory-Method/#resolution","text":"step by step instructions to solve issue","title":"Resolution:"},{"location":"Factory-Method/#preceding-patterns","text":"issues that may occur before this","title":"Preceding patterns:"},{"location":"Factory-Method/#following-patterns","text":"issues that may occur after this","title":"Following patterns:"},{"location":"Publish-Subscribe/","text":"Forces: explaination of issue Resolution: step by step instructions to solve issue Preceding patterns: issues that may occur before this Following patterns: issues that may occur after this","title":"Publish Subscribe"},{"location":"Publish-Subscribe/#forces","text":"explaination of issue","title":"Forces:"},{"location":"Publish-Subscribe/#resolution","text":"step by step instructions to solve issue","title":"Resolution:"},{"location":"Publish-Subscribe/#preceding-patterns","text":"issues that may occur before this","title":"Preceding patterns:"},{"location":"Publish-Subscribe/#following-patterns","text":"issues that may occur after this","title":"Following patterns:"},{"location":"observer/","text":"Forces: explaination of issue Resolution: step by step instructions to solve issue Preceding patterns: issues that may occur before this Following patterns: issues that may occur after this","title":"Observer"},{"location":"observer/#forces","text":"explaination of issue","title":"Forces:"},{"location":"observer/#resolution","text":"step by step instructions to solve issue","title":"Resolution:"},{"location":"observer/#preceding-patterns","text":"issues that may occur before this","title":"Preceding patterns:"},{"location":"observer/#following-patterns","text":"issues that may occur after this","title":"Following patterns:"},{"location":"singleton/","text":"Forces: Sometimes we will need to describe a type of object that will only have one instance variable. This is a design choice that we often need to ensure that only one instance will exist. Resolution: Ensures that only one object of its kind exists and provides a single point of access for any code. This is useful when exactly one object is needed to coordinate actions across the system. Implemented in C++: #include using namespace std; class Singleton { static Singleton *instance; int data; // Private constructor so that no objects can be created. Singleton() { data = 0; } public: static Singleton *getInstance() { if (!instance) instance = new Singleton; return instance; } int getData() { return this -> data; } void setData(int data) { this -> data = data; } }; //Initialize pointer to zero so that it can be initialized in first call to getInstance Singleton *Singleton::instance = 0; int main(){ Singleton *s = s->getInstance(); cout << s->getData() << endl; s->setData(100); cout << s->getData() << endl; return 0; } Preceding patterns: TBD Following patterns: TBD","title":"Singleton"},{"location":"singleton/#forces","text":"Sometimes we will need to describe a type of object that will only have one instance variable. This is a design choice that we often need to ensure that only one instance will exist.","title":"Forces:"},{"location":"singleton/#resolution","text":"Ensures that only one object of its kind exists and provides a single point of access for any code. This is useful when exactly one object is needed to coordinate actions across the system. Implemented in C++: #include using namespace std; class Singleton { static Singleton *instance; int data; // Private constructor so that no objects can be created. Singleton() { data = 0; } public: static Singleton *getInstance() { if (!instance) instance = new Singleton; return instance; } int getData() { return this -> data; } void setData(int data) { this -> data = data; } }; //Initialize pointer to zero so that it can be initialized in first call to getInstance Singleton *Singleton::instance = 0; int main(){ Singleton *s = s->getInstance(); cout << s->getData() << endl; s->setData(100); cout << s->getData() << endl; return 0; }","title":"Resolution:"},{"location":"singleton/#preceding-patterns","text":"TBD","title":"Preceding patterns:"},{"location":"singleton/#following-patterns","text":"TBD","title":"Following patterns:"},{"location":"visitor/","text":"Forces: explaination of issue Resolution: step by step instructions to solve issue Preceding patterns: issues that may occur before this Following patterns: issues that may occur after this","title":"Visitor"},{"location":"visitor/#forces","text":"explaination of issue","title":"Forces:"},{"location":"visitor/#resolution","text":"step by step instructions to solve issue","title":"Resolution:"},{"location":"visitor/#preceding-patterns","text":"issues that may occur before this","title":"Preceding patterns:"},{"location":"visitor/#following-patterns","text":"issues that may occur after this","title":"Following patterns:"}]}